---
title: "Bird Density vs. Ranks & Forest Attributes - SAMPLED STANDS" 
author: "Nicole Barker"
date: "Last updated: Jan 3, 2018"
output: 
  word_document:
    reference_docx: ../styles/ReportFormat_1.docx
---

##Script Abstract


# Question 1: How well do ranks predict observed bird density? 

## Approach 1. Descriptive plots of density vs. ranks

**Steps **

* Calculate the average (method/detectability-corrected) density for each forest stand type (ForID) that has at least one point count survey
* To get the average per stand type, I basically build a mean-model (no covariates), which also corrects for method via offsets. 
* Poisson GLM: Count + offset ~ ForID
    * Forest stand type as predictor
    * Count as response variable
    * TOTA offset as offset 
* **Data subset: Those stand types that were sampled by at least one bird point count survey** 



## Approach 2. Quantitatively analyze relationship between density (count with offset) and Rank



# Question 2: How does bird density relate to forest attributes?  


``` {r setup, echo=F, message=F, warning=F}
require(knitr)
opts_knit$set(root.dir = '..')
knitr::opts_chunk$set(
  fig.path = "figures/"
)
```

``` {r load.project, message=F}
require(ProjectTemplate)
load.project()
options(digits=12)
```


## Load data

``` {r}
load("cache/bird_vri_dat_ready.RData")
colnames(bird_vri_dat_ready)
tota <- bird_vri_dat_ready
colnames(tota)[which(colnames(tota) == "TOTA")] <- "Offset" #Peter's offsets had "TOTA" as the column name. Mine had "offset". This changes Peter's column to the consistent one. 
```

### Filter out some data I want to exclude from ranks vs. bird density analysis

**Stands that have ranks**

``` {r}
tota.qs <- tota
tota <- subset(tota, tota$Rank %in% 1:6)
```

**Stands that have been disturbed by insects**

``` {r}
tota.qs <- tota
tota$EARLIEST_NONLOGGING_DIST_TYPE <- gsub(" *$", "", tota$EARLIEST_NONLOGGING_DIST_TYPE) # remove trailing white space
nrow(tota[tota$EARLIEST_NONLOGGING_DIST_TYPE == "IBM",])
tota <- subset(tota, tota$EARLIEST_NONLOGGING_DIST_TYPE != "IBM")
```

**Surveys with large numbers of birds**

``` {r}
summary(tota$sumABUND)
nrow(tota[tota$sumABUND > 100,])
tota <- subset(tota, tota$sumABUND < 100)
```


**Include only one survey per sampling location (SS)**

A rigorous approach would involve repeating model building with multiple random sub-samples. However, in the interest of speed, I'm going to extract a single year of data from each SS that has multiple years of data. 

I'll choose the specific year based on its proximity to the VRI reference year. This is just a matter of sorting based on (difference between reference year and bird survey year) and keeping the first one. 

``` {r}
tota <- tota[order(tota$SS, tota$Difference_Bird_Photo),]

dupSS <- tota$SS[duplicated(tota$SS)] # the duplicated SSs

tota.nodup <- tota[!tota$SS %in% dupSS,]
tota.dupl <- tota[tota$SS %in% dupSS,]
rm(tota)

kable(tota.dupl[1:25,c("SS", "PKEY", "Difference_Bird_Photo", "Age")])

tota.dupl <- tota.dupl[!duplicated(tota.dupl$SS),] # cuts out all subsequently duplicated rows while keeping the first for each SS

tota <- rbind(tota.nodup, tota.dupl)
colnames(tota)[which(colnames(tota) == "sumABUND")] <- "Count"
```

**NOTES**

* This keeps a total of `r length(unique(tota$SS))` locations, each with `r length(unique(tota$PKEY)) / length(unique(tota$SS))` PKEY. (should be 1. I haven't removed all duplicates if this number is > 1)

#### Add factor labels 
``` {r} 
tota$BecZone <- factor(tota$BecZone) 
tota$BecZone <- factor(tota$BecZone, levels=levels(tota$BecZone), labels=c("BG/PP", "BWBS", "ESSF", "ICH/MH", "IDF", "MS", "SBS/SBPS", "SWB")) 
tota$SpeciesGroup <- factor(tota$SpeciesGroup) 
tota$Age <- factor(tota$Age) 
tota$Age <- factor(tota$Age, levels=levels(tota$Age)[c(3,4,5,1,2)], labels=c("3-30 yrs", "31-80 yrs", "81-120 yrs", "121-250 yrs", ">250 yrs")) 
tota$Height <- factor(tota$Height) 
levels(tota$Height) <- c("<10.5 m", "10.5-19.4 m", "19.5-28.4 m", "> 28.5 m") 
``` 
 

## Approach 1. Descriptive plots of density vs. ranks

``` {r}
hist(tota$Count)
mean(tota$Count)
var(tota$Count)
```


### Calculating average density per forest stand type 

Forest stand type is a factor with `r length(unique(tota$ForID))` levels

**Load previously fit GLMs if they exist**

``` {r fit.glm.forid, eval=T, echo=T}
if ("fit.dens.forid_tot_pois.RData" %in% dir("cache") == TRUE) { #conditional statements to automate loading and caching 
  load("cache/fit.dens.forid_tot_pois.RData")                    #on existence of cached model object.
}

if ("fit.dens.forid_tot_quasi.RData" %in% dir("cache") == TRUE) { #conditional statements to automate loading and caching 
  load("cache/fit.dens.forid_tot_quasi.RData")                    #on existence of cached model object.
}

```

**Run GLMs if they don't exist**

``` {r, warning=F, message=F}
if(!exists("fit.dens.forid_tot_pois")) {
  fit.dens.forid_tot_pois <- glm(Count ~ ForID-1, family=poisson, data=tota, offset=Offset)
  cache("fit.dens.forid_tot_pois")
}

if(!exists("fit.dens.forid_tot_quasi")) {
  fit.dens.forid_tot_quasi <- glm(Count ~ ForID-1, family=quasipoisson, data=tota, offset=Offset)
  cache("fit.dens.forid_tot_quasi")
}

library(arm)
cpois <-    coef(fit.dens.forid_tot_pois) #estimate
e.cpois <- exp(cpois)                     #expected value
s1 <- se.coef(fit.dens.forid_tot_pois)    #standard error

cquasi <-    coef(fit.dens.forid_tot_quasi)
e.cquasi <- exp(cquasi)
squasi <- se.coef(fit.dens.forid_tot_quasi)

coeftab <- as.data.frame(cbind(cpois, e.cpois, s1, cquasi, e.cquasi, squasi))
head(coeftab)

```

##### Calculate the number of birds in each forest stand type

Use 'predict' on the simple model above to attribute the mean density value for each forest stand type, after correcting for survey method. 

Only predicts to the forest stands we sampled. `r length(unique(tota$ForID))` unique stand types.

Basically just takes the mean of all samples within a forest stand type and adjusts by the offset. No covariates in the above model.

``` {r glm.forid.pred, eval=T}
dat.predict <- data.frame(ForID=unique(tota$ForID)) 
dat.predict$Offset <- 0 
dat.predict$Pred_fit.dens.forid_tot_pois <- predict(fit.dens.forid_tot_pois, newdata=dat.predict, type="response") 
kable(dat.predict[1:10,c("ForID", "Pred_fit.dens.forid_tot_pois", "Offset")]) 
tota <- merge(tota, dat.predict[c("ForID", "Pred_fit.dens.forid_tot_pois")], by="ForID", all.x=T) 
``` 
 
Since my GLM was intercept-less and ForID is the single covariate, exp(coef) are the group means. 
 
``` {r eval=T} 
coefs.forid <- data.frame(exp(coef(fit.dens.forid_tot_pois))) 
coefs.forid$ForID <- unlist(lapply(strsplit(row.names(coefs.forid), "ForID"), function(x) {x[2]})) 
tota <- merge(tota, coefs.forid, by="ForID") 
```

##### Double-check that these predictions make sense. 
Expectation: All point counts within the same forest stand type should have the same expected density, if I understand this analysis correctly. 

``` {r}
testset <- tota[tota$ForID %in% "SBS_SBPS.SwB_Decid.31_80.2",]
testset <- testset[order(testset$Pred_fit.dens.forid_tot, decreasing = F),]
testset$PredxExposure <- testset$Pred_fit.dens.forid_tot * testset$Exposure
testset$PredByExposure <- testset$Pred_fit.dens.forid_tot / testset$Exposure
kable(testset[1:10,c("ForID", "PKEY", "Pred_fit.dens.forid_tot_pois", "Exposure", "Offset", "PredxExposure", "PredByExposure", "exp.coef.fit.dens.forid_tot_pois..")], row.names=F, digits=3) 
```

**NOTES**

* Initially, my predictions were not the same for all polygons within a forest stand type. After talking to Peter, I realized this is because my Offsets in the "newdata" for the predictions were not 0. It's important to set Offset=0, which then forces the predictions (on response scale) to be expected density per unit area (hectare) and under perfect detection. * For the sake of preserving the research I did when trying to trouble-shoot this, let's work through the logic of an offset in a Poisson model... 
* Let's work through the logic of an offset in a Poisson model...
    * Count distributed as Poisson(exposure x expected density)
    * Linear predictor = log(exposure) + log(expected density)
    * log(exposure) = Offset
    * exp(Offset) is exposure
    * Response variable = count?
    * Expected count = exposure x expected density ?
    * Expected density =  Expected count / exposure 
    * So how do I estimate density if I don't have an offset??? e.g., trying to predict to unsampled locations. 
        * PUT OFFSET=0 INTO DATA I'M PREDICTING TO 

**MORE NOTES**

* I emailed a bit with Peter Solymos on Jan 3, 2018. 
    * Peter prefers not to use the predict function. Instead he uses `model.matrix()` to get the design matrix for the new data set and `X %*% coef()`. I didn't get this working, so continued with `predict` 
    * We also discussed that the coefs are group means, and therefore I don't even need to use 'predict' for this step. I double-checked that the predict means matched the coefs and they do. Yay. 


### Plotting correspondance between ranks and average observed density (in sampled stand types)

``` {r plot.foriddens.rank.corr, eval=T}
tota$EstDensity <- tota$Pred_fit.dens.forid_tot_pois 

ggplot(tota, aes(x=as.factor(Rank), y=EstDensity, group=as.factor(Rank), fill=as.factor(Rank))) + geom_boxplot() + xlab("Matrix Stand Rank") + ylab("Bird Density (# pairs/ha)") + myfacettheme2 + guides(fill=FALSE) + scale_fill_manual(values=palrank) 
 
ggplot(tota, aes(x=as.factor(Rank), y=EstDensity, group=as.factor(Rank), col=as.factor(Rank), fill=as.factor(Rank))) + geom_violin() + xlab("Matrix Stand Rank") + ylab("Bird Density (# pairs/ha)") + myfacettheme2 + guides(fill=FALSE) +  guides(col=FALSE) + scale_fill_manual(values=palrank) + scale_colour_manual(values=palrank) 
``` 


## Approach 2. Quantitatively analyze relationship between density (count with offset) and Rank 
 
 
 
 
 
 
 
 
 
# Question 2: How does bird density relate to forest attributes?  
 
 
 














































