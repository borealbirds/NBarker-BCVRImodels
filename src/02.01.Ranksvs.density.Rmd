---
title: "Ranks vs. Bird Density"
author: "Nicole Barker"
date: "Last updated: Jan 3, 2018"
output: 
  word_document:
    reference_docx: ../styles/ReportFormat_1.docx
---

##Script Abstract


# Question: How well do ranks predict observed bird density?

## Approach 1. Descriptive plots of density vs. ranks

**Steps **

* Calculate the average (method/detectability-corrected) density for each forest stand type (ForID) that has at least one point count survey
* To get the average per stand type, I basically build a mean-model (no covariates), which also corrects for method via offsets. 
* Poisson GLM: Count + offset ~ ForID
    * Forest stand type as predictor
    * Count as response variable
    * TOTA offset as offset 
* Data subset: Those stand types that were sampled by at least one bird point count survey.



## Approach 2. Quantitatively analyze relationship between density (count with offset) and Rank


``` {r setup, echo=F, message=F, warning=F}
require(knitr)
opts_knit$set(root.dir = '..')
knitr::opts_chunk$set(
  fig.path = "figures/"
)
```

``` {r load.project, message=F}
require(ProjectTemplate)
load.project()
options(digits=12)
```


## Load data

``` {r}
load("cache/bird_vri_dat_ready.RData")
colnames(bird_vri_dat_ready)
tota <- bird_vri_dat_ready
colnames(tota)[which(colnames(tota) == "TOTA")] <- "Offset" #Peter's offsets had "TOTA" as the column name. Mine had "offset". This changes Peter's column to the consistent one. 
```

### Filter out some data I want to exclude from ranks vs. bird density analysis

**Stands that have ranks**

``` {r}
tota.qs <- tota
tota <- subset(tota, tota$Rank %in% 1:6)
```

**Stands that have been disturbed by insects**

``` {r}
tota.qs <- tota
tota$EARLIEST_NONLOGGING_DIST_TYPE <- gsub(" *$", "", tota$EARLIEST_NONLOGGING_DIST_TYPE) # remove trailing white space
nrow(tota[tota$EARLIEST_NONLOGGING_DIST_TYPE == "IBM",])
tota <- subset(tota, tota$EARLIEST_NONLOGGING_DIST_TYPE != "IBM")
```

**Surveys with large numbers of birds**

``` {r}
summary(tota$sumABUND)
nrow(tota[tota$sumABUND > 100,])
tota <- subset(tota, tota$sumABUND < 100)
```


**Include only one survey per sampling location (SS)**

A rigorous approach would involve repeating model building with multiple random sub-samples. However, in the interest of speed, I'm going to extract a single year of data from each SS that has multiple years of data. 

I'll choose the specific year based on its proximity to the VRI reference year. This is just a matter of sorting based on (difference between reference year and bird survey year) and keeping the first one. 

``` {r}
tota <- tota[order(tota$SS, tota$Difference_Bird_Photo),]

dupSS <- tota$SS[duplicated(tota$SS)] # the duplicated SSs

tota.nodup <- tota[!tota$SS %in% dupSS,]
tota.dupl <- tota[tota$SS %in% dupSS,]
rm(tota)

kable(tota.dupl[1:25,c("SS", "PKEY", "Difference_Bird_Photo", "Age")])

tota.dupl <- tota.dupl[!duplicated(tota.dupl$SS),] # cuts out all subsequently duplicated rows while keeping the first for each SS

tota <- rbind(tota.nodup, tota.dupl)
colnames(tota)[which(colnames(tota) == "sumABUND")] <- "Count"
```

**NOTES**

* This keeps a total of `r length(unique(tota$SS))` locations, each with `r length(unique(tota$PKEY)) / length(unique(tota$SS))` PKEY. (should be 1. I haven't removed all duplicates if this number is > 1)

## Approach 1. Descriptive plots of density vs. ranks

``` {r}
hist(tota$Count)
mean(tota$Count)
var(tota$Count)
```


### Calculating average density per forest stand type 

Forest stand type is a factor with `r length(unique(tota$ForID))` levels

**Load previously fit GLMs if they exist**

``` {r fit.glm.forid, eval=T, echo=T}
if ("fit.dens.forid_tot_pois.RData" %in% dir("cache") == TRUE) { #conditional statements to automate loading and caching 
  load("cache/fit.dens.forid_tot_pois.RData")                    #on existence of cached model object.
}

if ("fit.dens.forid_tot_quasi.RData" %in% dir("cache") == TRUE) { #conditional statements to automate loading and caching 
  load("cache/fit.dens.forid_tot_quasi.RData")                    #on existence of cached model object.
}

```

**Run GLMs if they don't exist**

``` {r, warning=F, message=F}
if(!exists("fit.dens.forid_tot_pois")) {
  fit.dens.forid_tot_pois <- glm(Count ~ ForID-1, family=poisson, data=tota, offset=Offset)
  cache("fit.dens.forid_tot_pois")
}

if(!exists("fit.dens.forid_tot_quasi")) {
  fit.dens.forid_tot_quasi <- glm(Count ~ ForID-1, family=quasipoisson, data=tota, offset=Offset)
  cache("fit.dens.forid_tot_quasi")
}

library(arm)
cpois <-    coef(fit.dens.forid_tot_pois) #estimate
e.cpois <- exp(cpois)                     #expected value
s1 <- se.coef(fit.dens.forid_tot_pois)    #standard error

cquasi <-    coef(fit.dens.forid_tot_quasi)
e.cquasi <- exp(cquasi)
squasi <- se.coef(fit.dens.forid_tot_quasi)

coeftab <- as.data.frame(cbind(cpois, e.cpois, s1, cquasi, e.cquasi, squasi))
head(coeftab)

```

##### Calculate the number of birds in each forest stand type

Use 'predict' on the simple model above to attribute the mean density value for each forest stand type, after correcting for survey method. 

Only predicts to the forest stands we sampled. `r length(unique(tota$ForID))` unique stand types.

Basically just takes the mean of all samples within a forest stand type and adjusts by the offset. No covariates in the above model.

``` {r glm.forid.pred, eval=T}
tota$Pred_fit.dens.forid_tot_pois <- predict(fit.dens.forid_tot_pois, newdata=tota, type="response")
kable(tota[1:10,c("PKEY", "ForID", "Pred_fit.dens.forid_tot_pois", "Offset")])
```

##### Double-check that these predictions make sense. 
Expectation: All point counts within the same forest stand type should have the same expected density, if I understand this analysis correctly. 

``` {r}
testset <- tota[tota$ForID %in% "SBS_SBPS.SwB_Decid.31_80.2",]
testset <- testset[order(testset$Pred_fit.dens.forid_tot, decreasing = F),]
testset$PredxExposure <- testset$Pred_fit.dens.forid_tot * testset$Exposure
testset$PredByExposure <- testset$Pred_fit.dens.forid_tot / testset$Exposure
kable(testset[1:10,c("ForID", "PKEY", "Pred_fit.dens.forid_tot_pois", "Exposure", "Offset", "PredxExposure", "PredByExposure")], row.names=F, digits=3)
```

**NOTES**

* Predictions are not the same for all polygons within a forest stand type. See the top two rows for an example. 
* Let's work through the logic of an offset in a Poisson model...
    * Count distributed as Poisson(exposure x expected density)
    * Linear predictor = log(exposure) + log(expected density)
    * log(exposure) = Offset
    * exp(Offset) is exposure
    * Response variable = count?
    * Expected count = exposure x expected density ?
    * Expected density =  Expected count / exposure 
    * So how do I estimate density if I don't have an offset??? e.g., trying to predict to unsampled locations. 

**MORE NOTES**

* I emailed a bit with Peter Solymos on Jan 3, 2018. 
    * You want the offsets to be 0 for prediction. I do not use the predict function, but `model.matrix()` to get the design matrix for the new data set and `X %*% coef()`.

``` {r}
X <- model.matrix(fit.dens.forid_tot_pois)
tota$mm.preds <- X %*% coef(fit.dens.forid_tot_pois)
testset <- tota[tota$ForID %in% "SBS_SBPS.SwB_Decid.31_80.2",]
testset <- testset[order(testset$Pred_fit.dens.forid_tot, decreasing = F),]
testset$PredxExposure <- testset$Pred_fit.dens.forid_tot * testset$Exposure
testset$PredByExposure <- testset$Pred_fit.dens.forid_tot / testset$Exposure
kable(testset[1:10,c("ForID", "PKEY", "Pred_fit.dens.forid_tot_pois", "Exposure", "Offset", "PredxExposure", "PredByExposure", "mm.preds")], row.names=F, digits=3)

```

### Plotting correspondance between Forest stand ranks and their average observed density (in sampled stands)

``` {r plot.foriddens.rank.corr, eval=F}
tota$EstDensity <- tota$Pred_fit.dens.forid_tot / exp(tota$Offset) 

ggplot(tota, aes(x=as.factor(Rank), y=EstDensity, group=as.factor(Rank), fill=as.factor(Rank))) + geom_boxplot() + xlab("Rank") + ylab("EstDensity")

ggplot(tota, aes(x=as.factor(Rank), y=EstDensity, group=as.factor(Rank), col=as.factor(Rank), fill=as.factor(Rank))) + geom_violin() + myfacettheme + xlab("Rank") + ylab("EstDensity")

```


















































